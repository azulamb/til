# ドット絵をSVGにしたい

ドット絵をはっきりくっきりのSVGに変換したいと思います。

まず思いつくのはすべてのドットを `<rect>` にしてしまうことでしょうか。
ただこれだと拡大率によっては境目の部分に隙間が見えてしまうことがあります。
また色の変更などもつらいです。
そこでこれらをなんとかすべく、最適なパス（1色1パス）に変換したいと思います。

ここでは単色のドットの集合を1つのパスにすることを目標とします。

## 矩形を有向線分へ

とりあえず以下のようなドットを考えます。

```txt
■■
  ■
```

ここで1つの正方形を以下のような有向線分にします。

```txt
 --->
^    |
|    V
 <---
```

今回のドットを有向線分で表現すると以下になります。

```txt
 --->  --->
^    |^    |
|    V|    V
 <---  <---  --->
            ^    |
            |    V
             <---
```

ちなみに今回これは次のようなデータ構造で管理します。

```txt
{ sx: 始点X, sy: 始点Y, ex: 終点X, ey: 終点Y }
```

座標はすべて絶対値とします。

そのため上の図は以下のようになります。

```txt
{ sx: 0, sy: 0, ex: 1, ey, 0 }
{ sx: 1, sy: 0, ex: 1, ey, 1 }
{ sx: 1, sy: 1, ex: 0, ey, 1 }
{ sx: 0, sy: 1, ex: 0, ey, 0 }

{ sx: 1, sy: 0, ex: 2, ey, 0 }
{ sx: 2, sy: 0, ex: 2, ey, 1 }
{ sx: 2, sy: 1, ex: 1, ey, 1 }
{ sx: 1, sy: 1, ex: 1, ey, 0 }

{ sx: 2, sy: 1, ex: 3, ey, 1 }
{ sx: 3, sy: 1, ex: 3, ey, 2 }
{ sx: 3, sy: 2, ex: 2, ey, 2 }
{ sx: 2, sy: 2, ex: 2, ey, 1 }
```

## 有向線分の対消滅

例えば同じ座標セットだが `↓↑` のように逆の有向線分がセットで存在している場合があります。
（例えば `(0,0)→(1,0)` と `(1,0)→(0,0)` は始点終点に使われている座標が同じだが使用順番が逆なので向きが逆。）
ここは対消滅させます。

```txt

 --->  --->
^          |
|          V
 <---  <---  --->
            ^    |
            |    V
             <---
```

データでいうと次のようになります；

```txt
{ sx: 0, sy: 0, ex: 1, ey, 0 }
{ sx: 1, sy: 1, ex: 0, ey, 1 }
{ sx: 0, sy: 1, ex: 0, ey, 0 }

{ sx: 1, sy: 0, ex: 2, ey, 0 }
{ sx: 2, sy: 0, ex: 2, ey, 1 }
{ sx: 2, sy: 1, ex: 1, ey, 1 }

{ sx: 2, sy: 1, ex: 3, ey, 1 }
{ sx: 3, sy: 1, ex: 3, ey, 2 }
{ sx: 3, sy: 2, ex: 2, ey, 2 }
{ sx: 2, sy: 2, ex: 2, ey, 1 }

// これは対消滅
{ sx: 1, sy: 0, ex: 1, ey, 1 }
{ sx: 1, sy: 1, ex: 1, ey, 0 }
```

比較はAの始点とBの終点、Aの終点とBの始点が同じものを探すだけなので楽です。

## 最適化

次に延長線上の有向線分は統合しておきます。

```txt

 --------->
^          |
|          V
 <---------  --->
            ^    |
            |    V
             <---
```

判定はAの終点とBの始点が同じ座標で、両方ともX座標もしくはY座標が動かないものを混ぜます。
曲がり角になっているものは混ぜられないことに注意します。

データは次のようになります。


```txt
{ sx: 0, sy: 0, ex: 2, ey, 0 }
{ sx: 0, sy: 1, ex: 0, ey, 0 }

{ sx: 2, sy: 0, ex: 2, ey, 1 }
{ sx: 2, sy: 1, ex: 0, ey, 1 }

{ sx: 2, sy: 1, ex: 3, ey, 1 }
{ sx: 3, sy: 1, ex: 3, ey, 2 }
{ sx: 3, sy: 2, ex: 2, ey, 2 }
{ sx: 2, sy: 2, ex: 2, ey, 1 }

// これは混ざる
{ sx: 0, sy: 0, ex: 1, ey, 0 }
{ sx: 1, sy: 0, ex: 2, ey, 0 }
　↓
{ sx: 0, sy: 0, ex: 2, ey, 0 }

{ sx: 2, sy: 1, ex: 1, ey, 1 }
{ sx: 1, sy: 1, ex: 0, ey, 1 }
　↓
{ sx: 2, sy: 1, ex: 0, ey, 1 }
```

## パスにする

SVGはまずMで座標を動かすところから始めます。
次にLなどで座標を動かしながら描画していくのですが、そもそもドット絵は斜めに移動がないはずなので、H（横移動）とV（縦移動）を使うことになります。

一応今回使う命令をまとめておきます。

* M X,Y
  * パスを何もせず移動させる。
  * 一番初めに必ず必要。
* H X
  * 水平方向に絶対座標でXまでパスを進める。
* V Y
  * 垂直方向に絶対座標でYまでパスを進める。
* Z
  * パスを閉じる。
  * パスを閉じた後Mで移動すれば離れたパスを新たに追加できる。

最適化済みのためどこから始めても曲がり角スタートになっているはずなので、そこから始点に戻るパスを見つけていきます。

```txt
{ sx: 0, sy: 0, ex: 2, ey, 0 }
{ sx: 0, sy: 1, ex: 0, ey, 0 }

{ sx: 2, sy: 0, ex: 2, ey, 1 }
{ sx: 2, sy: 1, ex: 0, ey, 1 }

{ sx: 2, sy: 1, ex: 3, ey, 1 }
{ sx: 3, sy: 1, ex: 3, ey, 2 }
{ sx: 3, sy: 2, ex: 2, ey, 2 }
{ sx: 2, sy: 2, ex: 2, ey, 1 }
```

一番上から初めてパスを作っていきます。

```txt
{ sx: 0, sy: 0, ex: 2, ey, 0 }
{ sx: 2, sy: 0, ex: 2, ey, 1 }
{ sx: 2, sy: 1, ex: 0, ey, 1 }
{ sx: 0, sy: 1, ex: 0, ey, 0 }
```

上から順番につながるものを追加すると上の矩形で一つのパスになりました。

```txt
{ sx: 2, sy: 1, ex: 3, ey, 1 }
{ sx: 3, sy: 1, ex: 3, ey, 2 }
{ sx: 3, sy: 2, ex: 2, ey, 2 }
{ sx: 2, sy: 2, ex: 2, ey, 1 }
```

残りはこちらです。
つまりこの図形は2つの矩形パスで出来ていることになります。

SVGのパスでは以下のようになります。

```txt
M 0,0 H 2 V 1 H 0 V 0 Z
M 2,1 H 3 V 2 H 2 V 1 Z
```

## パスを更に最適化

しかし冷静に図形を見てみましょう。これは無駄なMがあります。
2つの矩形は一箇所共通の点があり大きい方の矩形はそこで左方向に進んでパスを閉じています。
しかし右方向に進めばもう一つの矩形も取り込めるのでパスが1つで済みます。

このようなケースに対応するため、ここでもう一度最適化します。

```txt
[
	{ sx: 0, sy: 0, ex: 2, ey, 0 }
	{ sx: 2, sy: 0, ex: 2, ey, 1 }
	{ sx: 2, sy: 1, ex: 0, ey, 1 }
	{ sx: 0, sy: 1, ex: 0, ey, 0 }
]
[
	{ sx: 2, sy: 1, ex: 3, ey, 1 }
	{ sx: 3, sy: 1, ex: 3, ey, 2 }
	{ sx: 3, sy: 2, ex: 2, ey, 2 }
	{ sx: 2, sy: 2, ex: 2, ey, 1 }
]
```

この2つのパスの頂点同士を調べ、Aの終点とBの始点が一致する場所を探します。

```txt
[
	{ sx: 0, sy: 0, ex: 2, ey, 0 }
	{ sx: 2, sy: 0, ex: 2, ey, 1 } // A
	{ sx: 2, sy: 1, ex: 0, ey, 1 }
	{ sx: 0, sy: 1, ex: 0, ey, 0 }
]
[
	{ sx: 2, sy: 1, ex: 3, ey, 1 } // B
	{ sx: 3, sy: 1, ex: 3, ey, 2 }
	{ sx: 3, sy: 2, ex: 2, ey, 2 }
	{ sx: 2, sy: 2, ex: 2, ey, 1 }
]
```

ここでAとBが見つかったので、Aの次にBを含むパスの中身を全部入れます。
今回はたまたま見つかった部分が開始点でしたが、開始点でない場合は開始点になるように調整します。

例えば以下のような場合です。

```txt
[
	{ sx: 3, sy: 2, ex: 2, ey, 2 }
	{ sx: 2, sy: 2, ex: 2, ey, 1 }
	{ sx: 2, sy: 1, ex: 3, ey, 1 } // B
	{ sx: 3, sy: 1, ex: 3, ey, 2 }
]
　↓
[
	{ sx: 2, sy: 2, ex: 2, ey, 1 }
	{ sx: 2, sy: 1, ex: 3, ey, 1 } // B
	{ sx: 3, sy: 1, ex: 3, ey, 2 }
	{ sx: 3, sy: 2, ex: 2, ey, 2 }
]
　↓
[
	{ sx: 2, sy: 1, ex: 3, ey, 1 } // B
	{ sx: 3, sy: 1, ex: 3, ey, 2 }
	{ sx: 3, sy: 2, ex: 2, ey, 2 }
	{ sx: 2, sy: 2, ex: 2, ey, 1 }
]
```

Bが先頭になるまで先頭の有向線分を一番後ろに追加し続ければよいです。

実際に準備ができたら以下のように追加します。

```txt
[
	{ sx: 0, sy: 0, ex: 2, ey, 0 }
	{ sx: 2, sy: 0, ex: 2, ey, 1 } // この後に代入
	{ sx: 2, sy: 1, ex: 3, ey, 1 } // ここが先程のパス
	{ sx: 3, sy: 1, ex: 3, ey, 2 }
	{ sx: 3, sy: 2, ex: 2, ey, 2 }
	{ sx: 2, sy: 2, ex: 2, ey, 1 } // 代入したパスの最後
	{ sx: 2, sy: 1, ex: 0, ey, 1 }
	{ sx: 0, sy: 1, ex: 0, ey, 0 }
]
```

無事繋がっているようなので、これをSVGのパスにします。

```txt
M 0,0 H 2 V 1 H 0 V 0 Z M 2,1 H 3 V 2 H 2 V 1 Z
　↓
M 0,0 H 2 V 1 H 3 V 2 H 2 V 1 H 0 V 0 Z
```

前より短くなっているのが分かります。

上はわかりやすくするためにスペースがありますがこのスペースは削除可能なのでまだ削れます。

またパスは同じ座標までくっつけなくてもその一つ手前で終わってZで閉じれば良いので最終的に以下になります。

```txt
M0,0H2V1H3V2H2V1H0Z
```

## その他

### 補足：中空

以下のような中空状態もあるでしょう。

```txt
■■■
■ ■
■■■
```

このような場合どうなるかというと、外側の矩形を描画した後内側の矩形が反時計回りに繋がれます。
これによって問題なく中空状態になるので、文字列化するときに何か考える必要は特にないです。

### 補足：隙間

マシにはなったものの拡大率によっては隙間が見えるでしょう。
ここについては諦めるかちょっとだけパスを広げるとかすれば良いと思います。

モノクロなど2色ならばそれぞれの色が1つのパスである限り隙間ができることはないです。

### パスを正方形に分割

パスを逆に正方形の塊に分割したい場合があります。
その場合はフォントの描画方法（モノクロ）を参考にします。

* 縦のパスを見つけたらそこより右に1を加算する。
* すべてのパスでこの作業を行うと数値が敷き詰められた二次元配列ができる。
* 奇数の部分だけ黒塗りする。

特に元がドットのパスなら分割も非常に楽なのでこれが使えそうです。

以下SVGのパスを実際に正方形に分割します。

```txt
M1,1H4V3H5V1H6V5H1ZM3,3H2V4H3Z
```

これを絶対値の有向線分の配列に直します。

```txt
[
	{ sx: 1, sy: 1, ex: 4, ey: 1 },
	{ sx: 4, sy: 1, ex: 4, ey: 3 },
	{ sx: 4, sy: 3, ex: 5, ey: 3 },
	{ sx: 5, sy: 3, ex: 5, ey: 1 },
	{ sx: 6, sy: 1, ex: 6, ey: 5 },
	{ sx: 6, sy: 5, ex: 1, ey: 5 },
	{ sx: 1, sy: 5, ex: 1, ey: 1 },
	{ sx: 3, sy: 3, ex: 2, ey: 3 },
	{ sx: 2, sy: 3, ex: 2, ey: 4 },
	{ sx: 2, sy: 4, ex: 3, ey: 4 },
	{ sx: 3, sy: 4, ex: 3, ey: 3 },
]
```

上からパスを見ていき、縦に進んでいるものの時だけ処理を行います。
（横移動は無視していい。）

```txt
[
	{ sx: 4, sy: 1, ex: 4, ey: 3 },
	{ sx: 5, sy: 3, ex: 5, ey: 1 },
	{ sx: 6, sy: 1, ex: 6, ey: 5 },
	{ sx: 1, sy: 5, ex: 1, ey: 1 },
	{ sx: 2, sy: 3, ex: 2, ey: 4 },
	{ sx: 3, sy: 4, ex: 3, ey: 3 },
]
```

有向線分は以下のように処理します。

* 少なくとも大きい方のY座標まで配列を縦に拡張する。
  * 新規追加は最低一つの値を入れた `[ 0 ]` にしておくと楽。
* 現在の横幅がX+1より小さい場合はX+1にする。
* 少なく横幅に至るまでは横に値を追加する。
  * 少なくとも1つ以上の値がある状態にして、Xの手前まで一番右の値をコピーする。
  * 例えば `[ 0, 1 ]` という配列があれば最後の1をコピーして `[ 0, 1, 1, ... ]` という形にする。
* 小さい方のY座標から大きい方のY座標まで、X座標から横幅までの値に1を足す。
  * 例えば `[ 0 0 1 ]` という配列があって `X = 1` の時は `[ 0 1 2 ]` となる。
  * `[ 0, 1 ]` で `X = 2` の時は上の処理で `[ 0, 1, 1 ]` になった後 `[ 0, 1, 2 ]` となる。

具体的には以下のように作業が進みます。

```txt
// { sx: 4, sy: 1, ex: 4, ey: 3 }
// width = 4 + 1
[ 0 0 0 0 0 ]
[ 0 0 0 0 1 ] *
[ 0 0 0 0 1 ] *
　↓
// { sx: 5, sy: 3, ex: 5, ey: 1 }
// width = 5 + 1
[ 0 0 0 0 0 0 ]
[ 0 0 0 0 1 2 ] *
[ 0 0 0 0 1 2 ] *
　↓
// { sx: 6, sy: 1, ex: 6, ey: 5 }
// width = 6 + 1
[ 0 0 0 0 0 0 0 ]
[ 0 0 0 0 1 2 3 ] *
[ 0 0 0 0 1 2 3 ] *
[ 0 0 0 0 0 0 1 ] *
[ 0 0 0 0 0 0 1 ] *
　↓
// { sx: 1, sy: 5, ex: 1, ey: 1 }
[ 0 0 0 0 0 0 0 ]
[ 0 1 1 1 2 3 4 ] *
[ 0 1 1 1 2 3 4 ] *
[ 0 1 1 1 1 1 2 ] *
[ 0 1 1 1 1 1 2 ] *
　↓
// { sx: 2, sy: 3, ex: 2, ey: 4 }
[ 0 0 0 0 0 0 0 ]
[ 0 1 1 1 2 3 4 ]
[ 0 1 1 1 2 3 4 ]
[ 0 1 2 2 2 2 3 ] *
[ 0 1 1 1 1 1 2 ]
　↓
// { sx: 3, sy: 4, ex: 3, ey: 3 }
[ 0 0 0 0 0 0 0 ]
[ 0 1 1 1 2 3 4 ]
[ 0 1 1 1 2 3 4 ]
[ 0 1 2 3 3 3 4 ] *
[ 0 1 1 1 1 1 2 ]
　↓
// 奇数ドットだけ色を塗る
[               ]
[   * * *   *   ]
[   * * *   *   ]
[   *   * * *   ]
[   * * * * *   ]
```

初めのパス情報をSVGに与えれば分かると思いますが、同じ図形が表示されたかと思います。

### 感想

とりあえず最適化込みでドット絵をSVGのパスにしてみました。
ドットのパス化に関しては以下サイトのアルゴリズムを参考にしました。

http://defghi1977.html.xdomain.jp/tech/dotrace/dotrace.htm

終盤のパスの最適化に関してはInkscapeでも同様の現象が起きていてこれはなんとか解消したいということで自分で考えた内容になります。
パスの開始地点の変更などは今回のようにそういうものがないからこそできるのであって他のパスベースの場合には利用できない可能性があります。
