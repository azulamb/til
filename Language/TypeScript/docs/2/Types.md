関数の話は脱線しすぎた分離か消去しよう

# JavaScriptの型

JavaScriptには見えないものの型が存在しています。

TypeScriptを使う上で、最低限の型の知識は必要かと思われるので、型についてまとめてあります。
なお、ここで辛い苦しいと書かれていることはTypeScriptで回避可能であったりするので、TypeScriptはいいぞ！！

（ちなみに、色々書いていますが正直斜め読みでも構いません。何か思ったよりめんどくさそうだし辛そうだぞ？っということと、なんかたくさん罠があるらしいということがわかれば、だいたい大丈夫です。）

## 型の調べ方

一応次のようにして型を調べることが出来ます。

```
console.log( typeof 1 );
```

この結果は文字列で `number` です。
このように文字列でその値や変数の型を調べることが出来ます。

（実は他にも様々な方法で型を調べることができる。というか厳密にやろうとすると様々な手法を使わねばならず辛さが半端ない。）

ここでは各基本的な型と注意点などをまとめています。


# 基本となる型

JavaScriptの型を調べるため、いくつか見てみます。


```
// 真偽値
console.log( typeof true );

// 数値
console.log( typeof 1 );

// 文字列
console.log( typeof '' );

// undefined
console.log( typeof undefined );

// null
console.log( typeof null );

// 配列
console.log( typeof [] );

// オブジェクト
console.log( typeof {} );

// 関数
console.log( typeof function(){} );

// クラス
console.log( typeof class{} );
```

結果は以下です。

```
boolean   // 真偽値
number    // 数値
string    // 文字列
undefined // undefined
object    // null
object    // 配列
object    // オブジェクト
function  // 関数
function  // クラス
```

Why? ってなるような所も多いと思います。そこが生のJSを使っている時に辛いところです。
例えば配列であることを調べたいのに、`typeof` とかいう型を調べてくれそうなやつを使っても、結果は `object` になるわけです。だいぶ辛いです。

とりあえず、JavaScriptでは大まかには上に出ている `boolean`, `number`, `string`, `undefined`, `object`, `function` が基本的な型となります。

## boolean

`boolean` は真偽値で、2つの値しかありません。
`true` と `false` です。

何かを比較していくと最終的この真偽値になる他、フラグを立てる際にも使います。

例えば今から調べる変数の型が数値だったら true を表示するプログラムは次のようになります。

```
const num = 1;
console.log( typeof num === 'number' );
```

`typeof` は型の名前を文字列で返してくれ、型が数値だった場合には `number` となります。

`===` は比較で、右と左が同じ場合には `true` となり、異なる場合には 'false' となります。
上のコードは、`typeof num === 'number'` → `'number' === 'number'` → `true` という流れで真偽値となり `true` が表示されています。

## number

`number` は数値です。整数も浮動小数点数も一緒です。

一応整数の概念もあるので、整数にしたい場合は以下のようにします。

```
const num = 1.1;
console.log( num );
console.log( Math.floor( num ) );
```

ちなみに、無限は `Infinity` で、不正数値は Not a Numberから `NaN` が割り当てられています。
このように特殊な状態には特殊な名前がありますが、注意事項があります。

```
// 不正な数値は数値の仲間なので、typeof的にはnumber
console.log(typeof NaN);
// NaN同士を比較しても false なので、数値が正常かどうかの判定にNaNは使えない。
console.log( NaN === NaN );
```

このように、比較や検査には使えないと思ってください。

## string

`string` は文字列です。
加工するためのメソッドが用意されている他、`length` で文字数も取得できます。早速確認してみましょう！！


```
// 3文字の長さなので3
console.log( 'aaa'.length );
// 日本語は1文字1換算なので1
console.log( 'あ'.length );
// こっちは2！
console.log( 'あい'.length );
// 絵文字は1になるはず……あれ？2？
console.log( '😀'.length );
```

文字列に関しては基本Unicodeですが、サロゲートペアと呼ばれるものが含まれた特殊な文字に関しては正確に文字数を `length` で取得することは出来ません。
絵文字の他特殊な漢字も含まれます。
文字数取得できるのは嘘ですごめんなさい。

最近は絵文字や特殊な漢字なども使われることが増えてきたので、こういった問題があることを把握しておきましょう。

## undefined

`undefined` は未定義の値です。確か宣言してない変数はそもそも扱ったらエラーになるのに何いってんだこいつ？っと思うでしょう。

例えば `undefined` は以下のような時に見られます。

```
let a;
console.log( a );
```

これを実行すると、`undefined` と表示されます。
このように宣言はされたものの中に値が入っていない時には `undefined` が使われます。

また、以下のように宣言されていない変数を使おうとすると存在すらしていないのでエラーになりますが

```
console.log( a ); // エラー
```

`typeof` を使えば存在しているかどうかをエラーなく確認できます。

```
console.log( typeof a );
```

この `undefined` のハマりポイントは、ズバリ代入できるということです。

```
let a = 1;
console.log( typeof a );
a = undefined;
console.log( typeof a );
```

結果は以下になります。

```
number
undefined
```

`undefined` だから存在すらしていない……というわけではなく、データ的には領域だけ存在するみたいなわけわからん状況が発生したりします。
初めはちょっと混乱するかもしれませんが、`undefined` を使いこなせば、いろいろ不思議な事もできるので、なんとなく覚えておいてください。

## object

`object` はJavaScriptでかなり自由自在にデータを入れることができるものです。
具体的には次のように使います。

```
const user = {
    id: 12345,
    name: 'ユーザー名',
    adult: true,
};
console.log( user );
console.log( user.name );
```

結果は以下です。

```
{ id: 12345, name: 'ユーザー名', adult: true }
ユーザー名
```

このように、任意のキー名（文字列）と値をセットで登録できます。
値には何でも入るので、オブジェクトの中にオブジェクトも入れれます。

### 配列について

JavaScriptの基本的な型はここで終了です。（残るは関数だが、これは実行ができるので他とはちょっと違う型。）

様々な言語には配列と呼ばれる、先頭から順番に値を並べたデータ構造がありますが、その型がJavaScriptにはありません。

しかし、JavaScriptにも配列はあります。簡単に書くと以下のような感じで使えます。

```
const array = [ 1, 2, 3 ];
// 配列は先頭を0番として、n番目の値を取得できる。
console.log( array[ 0 ] );
// 配列の先頭から数えて1番目 = 2番目の値となる。2番目の値に10を代入するので、[ 1, 10, 3 ] になる。
array[ 1 ] = 10;
// 配列はいくつの値を持っているか知ることもできる。
console.log( array.length );
```

広義では `object` 扱いされてしまうものの、このようにJavaScriptにも配列は存在します。

内部実装ガン無視で言ってしまえば、配列はキーが0から始まる数値のみで、`length` というキーには配列の値の数が入っているオブジェクトのことを指す。
っと言ってしまっても良いわけです。
そして、JavaScriptの表面上の挙動はまさにそれで、一昔前は配列に存在する値があれば配列ということにしよう！みたいな判別方法を使っていました。

（今のJavaScriptは `Array.isArray( 変数 )` でその変数が配列かどうか判定できます。）

ここら辺がとても辛いポイントとなりますが、TypeScriptでは配列がオブジェクトではなく配列として判定されるので非常に嬉しさがあったりします。

### nullについて

例えば空の文字列であれば `""` でも良いですが、オブジェクトが空である場合どのように扱えばよいでしょうか。`undefined`も思いつきますが、あれは未定義であって空ではありません。

実は、`undefined` と似たものに `null` というものがあり、一般的に空の値にはこの `null` を使います。

 `undefined` は未定義ですが、`null` は定義はされていてるが値が空です。
基本的には同じように空っぽの値に見える両者ですが、明確な違いが2つあります。

まず型ですが、`null` は `typeof` では `object` 扱いされます。あくまで `null` は空の値です。

また、次の例を見てみます。

```
const data = {
    name: null,
    job: undefined,
};
// データをすべて表示
console.log( data );
// jobを表示
console.log( data.job );
// 存在しないキー（age）を表示
console.log( data.age );
// データ構造を維持した文字列（JSON）に変換
console.log( JSON.stringify( data ) );
```

結果は以下のようになっています。

```
{ name: null, job: undefined }
undefined
undefined
{"name":null}
```

`undefined` を代入した `job` とそもそも `data` に存在すらしていない `age` はどちらも `undefined` という値なので、例えば `undefined` かどうかという観点で、存在しているかどうか判定することは出来ません。

一見役立たずに見える `undefined` ですが、このデータをJSONという文字列データに変換すると、`null` は残り、`undefined` を指定した `job` は項目が見当たりません。

JSONはJavaScriptの基本的なデータ構造を文字列化したもので、`number`、`string`、`boolean`、`object` が使えます。
JSONはJavaScriptで簡単に使える他、その他言語でも比較的簡単に使えるようライブラリが充実しており、特にWeb周りでよく使われる一般的なフォーマットです。

JSONでは存在しない値のキーを出力する必要はないので消す一方、データはないが項目は存在する `null` に関しては消さずに残すようになっています。

このように、`undefined` は存在していない未定義であるという意味があるため、何かの時に消えることがあります。
（例えばJSONとして一時的にブラウザにデータを保存した場合、後から読み込むと `undefined` は項目ごと消えている。しかし必ず消えるかと言うとそうではなく、配列の中途半端なところがundefinedだった場合、nullに置換されて配列の長さなどが維持されたりする。）

## function

`function` は関数です。

書き方についてはすでに基本的な後部運のところで扱っているので、ここでは主な特徴について書いておきます。

### 独自の空間になる

関数内はJavaScriptの中でも独自の空間になります。
変数で `const` を使おうが `let` を使おうが `var` を使おうが、ここから外には影響を与えません。

様々な変数をゴミとして外部に出さないため、以下のような処理を書くことがよくあります。

```
function init() {
    様々な処理
}

init();
```

もっというと関数定義もゴミになるからと、以下のようにします。

```
(function() {
    様々な処理
})();
```

これは

```
const init = function() { 様々な処理 }
( init )();
```

と分解すれば、何をしているか分かると思います。

### 壁を超えられないデータ

関数は処理をまとめて実行できるというその特性上、文字列にすることが出来ません。
具体的には、`console.log` でなんとなく今の状態を出力したりすることもあったりしますが、これを文字列として保持し、復旧させることが出来ません。

（`console.log` で関数を出力したとき、場合によってはnative codeと表示されたり、ソースコードが表示されるものの、それは一時的な表示であって文字列で保存できるわけではない。）

ブラウザでは履歴保存周りでデータをちょっとだけ保存できたり、Node.jsでも他のプロセスなどとのやり取りでJavaScriptのオブジェクトはよく受け渡しを行います。
それは簡単に言ってしまえばJSONにデータを変換したりJavaScriptのオブジェクトに戻せるからそういう事ができます。

そのため、オブジェクトの情報に出来ない関数は、プログラムが一度完全に再起動した後受けとるとか、別のプログラムに対しやり取りができないデータとなります。
これが今まで扱ってきたデータと最も異なる部分です。

### 特殊な this

`this` とは自分自身のオブジェクトを指し、主に関数やメソッド（オブジェクトに紐付いた操作関数）内で使われます。
クラスベースのオブジェクト指向型言語の場合、メソッド内で `this` はこのメソッドを持っているオブジェクトになります。

JavaScriptの `this` は非常に特殊で、かなりわけわからんことになっています。

#### 普通の関数

普通の関数は `this` グローバル空間になります。

```
console.log( typeof a );
function func() { this.a = 1; }
func();
console.log( a );
```

最初 `a` は定義すらされていなかったのに最後のには `1` を出力しています。

では次のパターンはどうかというと……

```
console.log( typeof a );
(function () {
    function func() { this.a = 1; }
    func();
})();
console.log( a );
```

こちらも大丈夫そうです。

#### オブジェクトの中の関数=メソッド

次にオブジェクトの中で定義してみます。

```
const obj = {
    count: 0,
    method: function() { this.count = this.count + 1; }
};
console.log( obj );
obj.method();
console.log( obj );
```

こちら、`console.log` の出力で `count` が `obj.method()` を呼び出すことで加算されていることがわかります。
このように、オブジェクトにくっついている関数=メソッドは、`this` がオブジェクトを指ししまします。

ただし、関数は変数に代入可能です。次はどうなるでしょう？

```
function countup() { this.count = this.count + 1; }
const obj1 = {
    count: 0,
    method: countup,
};
console.log( obj1 );
obj.method();
console.log( obj1 );
const obj2 = {
    count: 0,
    method: countup,
};
console.log( obj2 );
obj2.method();
console.log( obj2 );
```

はい。`this` が `obj1` にくっついてるときは `obj1` を、 `obj2` にくっついているときは `obj2` になっています。
同じ関数でもこのように `this` が変わります。

#### そしてヤバいやつ

```
const obj = {
    count: 0,
    method: function() {
        this.count = this.count + 1;
        
        // 表示する関数
        function show() {
            console.log( this.count );
        }
        show();
    }
};
console.log( obj );
obj.method();
```

なんとなく意図としては `method` 内で表示関数を定義して、そっちで `obj.count` を表示しようとしていますね。
上で `this.count` に対する演算が効いていることから、`this` は `obj` ですもんね。

結果は、`obj.method()` 実行時に `undefined` が表示されます。
なぜなら `method()` は `obj` にくっついているので `this` が `obj` になりますが、普通の関数の `this` はグローバル空間を指すからです。

##### 対処法

```
const obj = {
    count: 0,
    method: function() {
        this.count = this.count + 1;
        
        // アロー関数式に書き換える
        const show = () => {
            console.log( this.count );
        }
        show();
    }
};
console.log( obj );
obj.method();
```

アロー関数式は宣言されたときに this が何者か決めてしまいます。
今回 `show()` が 定義されているの時の `this` は `obj` なので、これがそのまま引き継がれています。

また以下のようにも可能です。

```
const obj = {
    count: 0,
    method: function() {
        this.count = this.count + 1;
        
        // 表示する関数
        function show() {
            console.log( this.count );
        }
        show.apply( this );
    }
};
console.log( obj );
obj.method();
```

`関数.apply( thisに設定するオブジェクト )` という呼び出し方をすると、`apply()` に渡されているオブジェクトを、関数の `this` に置き換えてくれます。

#### 関数における `this` はやばい

このように、関数における `this` はコロコロ変わってしまうため、慣れないとthisとは何かという哲学の問題を解くような気分になります。
関数内で `this` を使う場合は、`this` とは何者かはっきりさせるか、アロー関数式を使って定義時の `this` を引き継ぐようにしましょう。

ちなみにTypeScriptはここら辺も型チェックしてくれるのでいいぞ！！


# 型が曖昧な場合に起こりうるバグ

今まで散々型の判別が辛いみたいなことしか書いていないのですが、別に型は曖昧でも良くない？っと思う方もいるでしょう。

上で扱ってきたのような型に関するバグはまだわかりやすいのですが、例えば `parseInt` などの実際の値にまつわる型のバグはかなり根深かったりします。
普通に考えると理解不能なことの連続に、皆さん頭を抱えることでしょう。

実際に頭を抱えてもらいます。

`parseInt( 文字列 )` は与えられた文字列を第二引数の進数で解釈して返す挙動なので、以下のような挙動になります。

```
console.log( parseInt( '1' ) );
console.log( parseInt( '0.0000009' ) );
```

結果は以下です。

```
1
0
```

まぁ理解できますね。では、数値を入れるとどうなるでしょう？

```
console.log( parseInt( 0.0000009 ) );
```

結果は以下です。

```
9
```

9……？なぜ？

文字列の1を整数に直せば1です。
文字列の0.0000009を整数に直せば小数点以下を無視して0です。

では、なぜ数値の0.0000009を整数にすると9になるのか。

その答えは以下です。

```
console.log( 0.0000009.toString() );
console.log( parseInt( 0.0000009.toString() ) );
console.log( parseInt( 0.0000009 ) );
```

結果は以下です。

```
9e-7
9
9
```

`paraseInt` は与えられた変数が文字列であることを前提としています。
数値を与えた場合、まず文字列に変換してから処理が行われます。

結果`、0.0000009` を文字列にした場合 `9e-7` となり、この文字列を整数に変換する場合、9までは認識して、次の文字が数値ではないのでそこで変換を終了し、9という結果を返します。（ちなみにこの9e-7は、`9 * 10の-7乗` = `9 * 0.1の7乗` = `9 * 0.0000001` = `0.0000009` という意味です。 ）

このように、JavaScriptは見えないからといって型を無視するわけにはいきません。
それっぽく動いているように見えても、実際に動かしてみたら動かないケースというものが存在します。

ちなみに、TypeScriptではそもそも `parseInt` に数値を突っ込もうとした時点でエラーとなるため、このようなエラーは発生しません。

# まとめ

JavaScriptには見えないものの型はあります。
そして、見えないからと言って適当に使うと変なバグを発生させ、それを回避するために型を判定しようにも正確に判定できないことが多々あります。

TypeScriptはそのような現象に対する強力な武器となりえます。
