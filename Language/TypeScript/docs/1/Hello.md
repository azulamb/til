# 初めてのTypeScript

まず適当なフォルダを作り、`hello.ts` を以下の内容で作成します。

```
console.log( 'Hello!' );
```

次に以下コマンドでビルドを行います。

```
tsc hello.js
```

ビルド結果として、`hello.js` が出力されたと思いますので、中身を確認してみます。

```
console.log('Hello!');
```

ちょっとスペースが変わったくらいで、ほぼ同じですね。これをNode.jsで実行します。

```
node hello.js
```

以下のように出力されればOKです。

```
Hello!
```

# 型を見る

次に型を型を書かずに体験してみます。

JavaScriptにはいくつか基本的な型があります。
とりあえず最も簡単なのは数値と文字列でしょう。

```
// 数値を代入しているので、これは数値
let num = 0;

// 別の数値を代入してみる
num = 2;

// 文字列を代入しているので、これは文字列
const str = "Hello!";

// 文字列と数値を足すと、数値が文字列に変換されて、文字列の結合になる
console.log( str + num );
```

このコードは以下のようになります。

```
// 数値を代入しているので、これは数値
var num = 0;
// 別の数値を代入してみる
num = 2;
// 文字列を代入しているので、これは文字列
var str = "Hello!";
// 文字列と数値を足すと、数値が文字列に変換されて、文字列の結合になる
console.log(str + num);
```

実行結果は以下です。

```
Hello!2
```

一昔前のJavaScriptは、変数の宣言には `var` しか使えませんでした。
これは別のページで再度説明しますが、かなり変なスコープなため、使いづらいだけでなくバグの原因ともなっています。

これに対し、最新のJavaScriptやTypeScriptでは `let` や `const` という宣言が使えるようになりました。
`let`は再度値を代入することができる変数で、`const`は一度代入したら再度値を代入できない変数です。

今回のポイントは以下2つです。

* 簡単な型推論はしてくれる
* 古いJSで実行できる形に変換している

まず、今回型の定義をしていませんが、数値に数値を入れても特にエラーは出ていません。
この後試しますが、簡単な型推論は行ってくれるので、型を必ずしも書く必要はありません。

次に、変換についてです。
TypeScriptは無設定だと古い方のJavaScriptでも動くようにコンパイルしてくれるので、`const`は今回`var`に変換されています。

# 型エラー

次にわざとエラーとなるようなプログラムを書いてみます。

```
// numは数値
let num = 0;

// numは数値なのに文字列を代入しようとしているのでエラー
num = 'test';

console.log( num );
```

ビルドすると以下のようにエラーが出力されると思います。

```
error.ts(5,1): error TS2322: Type '"test"' is not assignable to type 'number'.
```

5行目、`"test"`は数値(`number`)じゃねぇぞ！！って怒られています。

しかし、結果が出力されていて、以下のようになっています。

```
// numは数値
var num = 0;
// numは数値なのに文字列を代入しようとしているのでエラー
num = 'test';
console.log(num);
```

ちなみに実行もできます。

```
test
```

まず、出力したJavaScriptのコードですが、JavaScript的にこれはエラーではありません。
再度代入された時点で `num` は文字列を格納した変数に変わってしまったので、そのまま実行できます。
JavaScriptはこのような事が可能なため、変数名と中身が一致していないコードを書いたりすると、たちまちバグの原因となります。
それを避けるためのTypeScriptで、実際にエラーが出力されています。

しかし、なぜかJavaScriptのコードが出力されています。

TypeScriptはJavaScriptのスーパーセット。つまり、ほぼJavaScriptだけどそれより広い範囲を扱える言語です。
なので、この程度の小さいエラーであれば、型エラーではあっても構文エラーではないため普通に無視して結果が出力可能です。

本当に最悪のケースですが、普通にエラーは出るけどビルドして出力することも可能です。（初めて本格的に使った時、型エラーの回避方法がわからなくてこの方法を使ったことが……。もちろんそれを回避する方法は今後書いていきます。）
